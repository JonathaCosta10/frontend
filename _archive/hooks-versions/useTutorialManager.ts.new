import { useState, useEffect, useCallback } from 'react';
import { useLocation } from 'react-router-dom';
import { useOnboarding } from './useOnboarding';
import { useAuth } from '../contexts/AuthContext';
import { api } from '../lib/api';
import DataCache from '../utils/DataCache';

// Tipo para os dados histÃ³ricos
export interface HistData {
  replicar_entradas: boolean;
  replicar_gastos: boolean;
  replicar_dividas: boolean;
  ultimo_registro_mes: number | null;
  ultimo_registro_ano: number | null;
}

// Tipo para a resposta da API de distribuiÃ§Ã£o de gastos
interface DistribuicaoGastosResponse {
  ano: string;
  meses_disponeis: string[];
  dados_mensais: Record<string, any>;
  metas_personalizadas: any;
  hist_data: HistData;
}

export type TutorialType = 'general' | 'dailyInfo' | 'budget' | 'variableIncome';

export function useTutorialManager() {
  const location = useLocation();
  const pathname = location.pathname;
  const { hasTutorialBeenCompleted, completeTutorial } = useOnboarding();
  const { isAuthenticated, user } = useAuth();
  
  const [activeTutorial, setActiveTutorial] = useState<TutorialType | null>(null);
  const [histData, setHistData] = useState<HistData | null>(null);
  const [mesesDisponiveis, setMesesDisponiveis] = useState<string[]>([]);
  const [showReplicateData, setShowReplicateData] = useState(false);
  const [isLoadingData, setIsLoadingData] = useState(false);
  const [hasCheckedBudgetData, setHasCheckedBudgetData] = useState(false);
  const [dataFullyLoaded, setDataFullyLoaded] = useState(false);
  const [lastSuccessfulLoad, setLastSuccessfulLoad] = useState<number>(0);
  const [buttonStateCache, setButtonStateCache] = useState<Record<string, boolean>>({});
  const [retryAfterTokenRefresh, setRetryAfterTokenRefresh] = useState(false);
  const [requestInProgress, setRequestInProgress] = useState<string | null>(null); // Cache para requisiÃ§Ãµes em andamento

  // REGRA PRINCIPAL: Sistema estÃ¡ completamente vazio?
  const isSystemCompletelyEmpty = (data: HistData, mesesDisponiveis: string[]): boolean => {
    const noHistData = (
      data.replicar_entradas === false &&
      data.replicar_gastos === false &&
      data.replicar_dividas === false &&
      data.ultimo_registro_mes === null &&
      data.ultimo_registro_ano === null
    );
    
    const noAvailableMonths = mesesDisponiveis.length === 0;
    
    console.log('ðŸŽ¯ Verificando se sistema estÃ¡ completamente vazio:', {
      noHistData,
      noAvailableMonths,
      isEmpty: noHistData && noAvailableMonths,
      data,
      mesesDisponiveis
    });
    
    return noHistData && noAvailableMonths;
  };

  // REGRA: Tem dados histÃ³ricos para replicar?
  const hasDataToReplicate = (data: HistData, mesesDisponiveis: string[]): boolean => {
    const hasHistoricalData = (
      data.ultimo_registro_mes !== null &&
      data.ultimo_registro_ano !== null &&
      (data.replicar_entradas || data.replicar_gastos || data.replicar_dividas)
    );
    
    console.log('ðŸ”„ Verificando se tem dados para replicar:', {
      hasHistoricalData,
      ultimo_registro_mes: data.ultimo_registro_mes,
      ultimo_registro_ano: data.ultimo_registro_ano,
      flags: {
        replicar_entradas: data.replicar_entradas,
        replicar_gastos: data.replicar_gastos,
        replicar_dividas: data.replicar_dividas
      }
    });
    
    return hasHistoricalData;
  };

  // VersÃ£o simplificada da verificaÃ§Ã£o de dados para replicar
  const hasDataToReplicateSimple = () => {
    return hasDataToReplicate(histData || {
      replicar_entradas: false,
      replicar_gastos: false,
      replicar_dividas: false,
      ultimo_registro_mes: null,
      ultimo_registro_ano: null
    }, mesesDisponiveis);
  };

  // FUNÃ‡ÃƒO PRINCIPAL: Decidir se mostra botÃ£o de replicaÃ§Ã£o
  const shouldShowReplicateButton = useCallback((selectedMes?: string, selectedAno?: string) => {
    // CONDIÃ‡ÃƒO 0: Evitar verificaÃ§Ãµes durante carregamento
    if (isLoadingData) {
      console.log('â³ [BOTÃƒO REPLICAÃ‡ÃƒO] Aguardando carregamento...');
      return false;
    }
    
    // Cache key para evitar recÃ¡lculos desnecessÃ¡rios
    const cacheKey = `${selectedMes || 'current'}-${selectedAno || 'current'}-${dataFullyLoaded}-${lastSuccessfulLoad}`;
    
    // Se jÃ¡ temos resultado em cache, usar diretamente
    if (buttonStateCache[cacheKey] !== undefined) {
      console.log('ðŸ’¾ [BOTÃƒO REPLICAÃ‡ÃƒO] Usando cache:', { cacheKey, cached: buttonStateCache[cacheKey] });
      return buttonStateCache[cacheKey];
    }

    console.log('ðŸ” [BOTÃƒO REPLICAÃ‡ÃƒO] Verificando condiÃ§Ãµes...', {
      dataFullyLoaded,
      isLoadingData,
      hasHistData: !!histData,
      selectedMes,
      selectedAno,
      mesesDisponiveis,
      timestamp: new Date().toISOString()
    });

    // CONDIÃ‡ÃƒO 1: Dados devem estar COMPLETAMENTE carregados
    if (!dataFullyLoaded || !histData) {
      console.log('âŒ [BOTÃƒO REPLICAÃ‡ÃƒO] FALHOU - Dados nÃ£o carregados', {
        dataFullyLoaded,
        hasHistData: !!histData,
        razao: !dataFullyLoaded ? 'dataFullyLoaded=false' : 'histData=null'
      });
      setButtonStateCache(prev => ({ ...prev, [cacheKey]: false }));
      return false;
    }

    // CONDIÃ‡ÃƒO 2: Deve ter dados histÃ³ricos para replicar
    const hasHistoricalData = hasDataToReplicate(histData, mesesDisponiveis);
    if (!hasHistoricalData) {
      console.log('âŒ [BOTÃƒO REPLICAÃ‡ÃƒO] FALHOU - Sem dados histÃ³ricos vÃ¡lidos');
      setButtonStateCache(prev => ({ ...prev, [cacheKey]: false }));
      return false;
    }

    // CONDIÃ‡ÃƒO 3: Se mÃªs especÃ­fico foi fornecido, verificar se esse mÃªs NÃƒO tem dados
    if (selectedMes) {
      const monthHasNoData = !mesesDisponiveis.includes(selectedMes);
      
      console.log('ðŸŽ¯ [BOTÃƒO REPLICAÃ‡ÃƒO] VerificaÃ§Ã£o mÃªs especÃ­fico:', {
        selectedMes,
        mesesDisponiveis,
        monthHasNoData,
        resultado: monthHasNoData ? 'MOSTRAR BOTÃƒO âœ…' : 'NÃƒO MOSTRAR âŒ'
      });
      
      // Guardar resultado em cache para evitar recÃ¡lculos
      setButtonStateCache(prev => ({ ...prev, [cacheKey]: monthHasNoData }));
      return monthHasNoData;
    }

    // CONDIÃ‡ÃƒO 4: VerificaÃ§Ã£o padrÃ£o para mÃªs atual
    const currentDate = new Date();
    const currentMonthStr = (currentDate.getMonth() + 1).toString().padStart(2, '0');
    const shouldShow = !mesesDisponiveis.includes(currentMonthStr);
    
    console.log('ðŸŽ¯ [BOTÃƒO REPLICAÃ‡ÃƒO] VerificaÃ§Ã£o mÃªs atual:', {
      currentMonthStr,
      mesesDisponiveis,
      shouldShow,
      resultado: shouldShow ? 'MOSTRAR BOTÃƒO âœ…' : 'NÃƒO MOSTRAR âŒ'
    });
    
    // Armazenar resultado no cache
    setButtonStateCache(prev => ({ ...prev, [cacheKey]: shouldShow }));
    return shouldShow;
  }, [dataFullyLoaded, isLoadingData, buttonStateCache, histData, mesesDisponiveis, lastSuccessfulLoad, hasDataToReplicate]);

  // FunÃ§Ã£o para buscar dados do orÃ§amento
  const checkBudgetData = useCallback(async (year?: string, forceReload: boolean = false) => {
    const currentYear = year || new Date().getFullYear().toString();
    const requestKey = `budget-${currentYear}`;
    
    // Verificar se jÃ¡ hÃ¡ uma requisiÃ§Ã£o em andamento para evitar duplicatas
    if (requestInProgress === requestKey && !forceReload) {
      console.log('â³ RequisiÃ§Ã£o jÃ¡ em andamento para:', requestKey);
      return;
    }
    
    if (isLoadingData && !forceReload) {
      console.log('â³ JÃ¡ carregando dados...');
      return;
    }

    try {
      setRequestInProgress(requestKey);
      setIsLoadingData(true);
      setButtonStateCache({}); // Limpar cache antes de carregar novos dados
      
      console.log('ðŸ” Buscando dados do orÃ§amento para ano:', currentYear);
      
      // Tentar obter dados da API
      let data: DistribuicaoGastosResponse | null = null;
      let response;
      
      try {
        response = await api.get(`/api/distribuicao_gastos?ano=${currentYear}`);
        data = response.data as DistribuicaoGastosResponse;
        
        // Se deu certo, salvar no cache global
        if (data && data.hist_data) {
          DataCache.setBudgetData(currentYear, data);
        }
      } catch (innerError) {
        console.log('âš ï¸ [API ERROR] Erro na chamada inicial, tentando usar cache:', innerError);
        
        // Tentar usar o cache se disponÃ­vel
        data = DataCache.getBudgetData(currentYear) as DistribuicaoGastosResponse;
        
        if (!data) {
          // Se nÃ£o tiver cache, propagar o erro
          throw innerError;
        }
        
        console.log('âœ… [CACHE RECOVERY] Dados recuperados do cache com sucesso');
      }
      
      console.log('ðŸ“Š [API SUCCESS] Dados recebidos:', {
        status: response?.status || 'no-status',
        data: data ? 'available' : 'undefined',
        timestamp: new Date().toISOString()
      });
      
      // CORREÃ‡ÃƒO CRÃTICA: Verificar se data estÃ¡ definido e contÃ©m dados vÃ¡lidos
      if (!data) {
        throw new Error('Dados indisponÃ­veis mesmo apÃ³s tentativa de recuperaÃ§Ã£o via cache');
      }
      
      // Atualizar os estados do componente com os dados recuperados
      setHistData(data.hist_data);
      setMesesDisponiveis(data.meses_disponeis || []);
      
      // Dados completamente carregados
      setHasCheckedBudgetData(true);
      setDataFullyLoaded(true);
      setLastSuccessfulLoad(Date.now());
      setRequestInProgress(null);
      setIsLoadingData(false);
      
      // Aplicar as regras de negÃ³cio apÃ³s obter dados
      if (data.hist_data && Array.isArray(data.meses_disponeis)) {
        const systemEmpty = isSystemCompletelyEmpty(data.hist_data, data.meses_disponeis || []);
        const hasReplicableData = hasDataToReplicate(data.hist_data, data.meses_disponeis || []);
        
        console.log('ðŸ”„ VerificaÃ§Ã£o de sistema para tutoriais:', { systemEmpty, hasReplicableData });
        
        // Se o sistema estiver vazio, nÃ£o mostrar o botÃ£o de replicaÃ§Ã£o
        if (systemEmpty) {
          setShowReplicateData(false);
          
          if (pathname === '/dashboard/orcamento' && !hasTutorialBeenCompleted('budget')) {
            // Verificar se jÃ¡ completou o tutorial geral
            if (!hasTutorialBeenCompleted('general')) {
              setActiveTutorial('general');
            } else {
              setActiveTutorial('budget');
            }
          } else {
            setActiveTutorial(null);
          }
        }
        // Se tiver dados para replicar, mostrar o botÃ£o
        else if (hasReplicableData) {
          setShowReplicateData(true);
          setActiveTutorial(null);
        }
      }
      
      return data; // Retornar os dados para quem chamou a funÃ§Ã£o
    } catch (error) {
      console.error('âŒ [API ERROR] Erro ao buscar dados do orÃ§amento:', error);
      
      // Em caso de erro, limpar a requisiÃ§Ã£o em andamento e indicar que o carregamento terminou
      setRequestInProgress(null);
      setIsLoadingData(false);
      setDataFullyLoaded(false);
      setHasCheckedBudgetData(true);
      setRetryAfterTokenRefresh(true);
      
      return null;
    }
  }, [histData, isLoadingData, pathname, hasTutorialBeenCompleted, requestInProgress]);
  
  // FUNÃ‡ÃƒO: Replicar dados de um mÃªs anterior para o mÃªs atual
  const handleReplicateData = useCallback(async (fromMonth?: number, fromYear?: number) => {
    const today = new Date();
    const targetMonth = today.getMonth() + 1; // 1-12
    const targetYear = today.getFullYear();
    
    const sourceMonth = fromMonth || (histData?.ultimo_registro_mes || targetMonth);
    const sourceYear = fromYear || (histData?.ultimo_registro_ano || targetYear);
    
    console.log('ðŸ”„ Replicando dados:', {
      de: { mes: sourceMonth, ano: sourceYear },
      para: { mes: targetMonth, ano: targetYear }
    });
    
    try {
      await api.post('/api/replicar_dados', {
        mes_origem: sourceMonth,
        ano_origem: sourceYear,
        mes_destino: targetMonth,
        ano_destino: targetYear
      });
      
      console.log('âœ… Dados replicados com sucesso!');
      
      // Atualizar a UI apÃ³s a replicaÃ§Ã£o
      checkBudgetData(String(targetYear), true);
      
      return true;
    } catch (error) {
      console.error('âŒ Erro ao replicar dados:', error);
      return false;
    }
  }, [histData, checkBudgetData]);
  
  // Efeito para carregar dados iniciais
  useEffect(() => {
    const loadInitialData = async () => {
      console.log('ðŸ”„ useEffect principal:', {
        pathname,
        hasCheckedBudgetData,
        isLoadingData,
        dataFullyLoaded
      });
      
      // SÃ³ carregar dados do orÃ§amento nas pÃ¡ginas relacionadas
      if (pathname.startsWith('/dashboard/orcamento') || pathname === '/dashboard') {
        if (!hasCheckedBudgetData && !isLoadingData) {
          console.log('ðŸ”„ Iniciando carregamento de dados do orÃ§amento');
          
          // Verificar se temos ano especÃ­fico na URL
          const urlParams = new URLSearchParams(location.search);
          const anoParam = urlParams.get('ano');
          
          // Carregar dados para o ano especificado ou para o ano atual
          await checkBudgetData(anoParam || undefined);
        }
      }
    };
    
    if (isAuthenticated && user) {
      loadInitialData();
    }
  }, [isAuthenticated, user, pathname, hasCheckedBudgetData, isLoadingData, location.search, checkBudgetData]);
  
  // Monitorar token refresh para tentar novamente em caso de falhas por autenticaÃ§Ã£o
  useEffect(() => {
    // Apenas tentar novamente se estiver configurado para tal
    if (retryAfterTokenRefresh && pathname.startsWith('/dashboard/orcamento')) {
      console.log('ðŸ”„ Tentando carregar dados novamente apÃ³s refresh de token');
      
      // Resetar o flag e tentar carregar os dados novamente
      setRetryAfterTokenRefresh(false);
      
      // Esperar um pouco antes de tentar novamente
      const timer = setTimeout(() => {
        checkBudgetData(undefined, true);
      }, 1000);
      
      return () => clearTimeout(timer);
    }
  }, [retryAfterTokenRefresh, pathname, checkBudgetData]);
  
  // Monitorar mudanÃ§as de token para fazer retry
  useEffect(() => {
    console.log('ðŸŽ¯ [TOKEN LISTENER] Registrando listeners de token refresh:', {
      pathname,
      retryAfterTokenRefresh,
      timestamp: new Date().toISOString()
    });
    
    // Definir um contador de tentativas para evitar loops infinitos
    const retryCountKey = 'errorRetryCount';
    const currentRetries = parseInt(localStorage.getItem(retryCountKey) || '0');
    
    // AGGRESSIVE RETRY: Se ainda estiver na pÃ¡gina de orÃ§amento e tiver tokens atualizados, tentar novamente
    if (pathname.startsWith('/dashboard/orcamento') && currentRetries < 3) {
      localStorage.setItem(retryCountKey, String(currentRetries + 1));
      
      // Verificar se jÃ¡ tentamos vÃ¡rias vezes e falhou
      if (currentRetries >= 2) {
        console.log('âš ï¸ [AGGRESSIVE RETRY] NÃºmero mÃ¡ximo de tentativas atingido:', currentRetries);
        localStorage.removeItem(retryCountKey);
        return;
      }
      
      // Tentar novamente com delay
      const timer = setTimeout(() => {
        console.log('ðŸ”„ [AGGRESSIVE RETRY] Tentativa', currentRetries + 1);
        
        // ForÃ§ar atualizaÃ§Ã£o apenas se precisar
        if (!dataFullyLoaded) {
          checkBudgetData(undefined, true);
        }
      }, 2000 * (currentRetries + 1)); // Backoff exponencial
      
      return () => clearTimeout(timer);
    } else if (!pathname.startsWith('/dashboard/orcamento')) {
      // Limpar contador de tentativas ao sair da pÃ¡gina de orÃ§amento
      localStorage.removeItem(retryCountKey);
    }
  }, [pathname, user, dataFullyLoaded, checkBudgetData]);
  
  // FunÃ§Ã£o para determinar qual tutorial deve estar ativo com base na URL atual
  const getActiveTutorialForPage = useCallback(() => {
    if (pathname === '/dashboard' && activeTutorial === 'general') {
      return 'general';
    } else if (pathname === '/dashboard/orcamento' && activeTutorial === 'budget') {
      return 'budget';
    } else if (pathname === '/dashboard/info' && activeTutorial === 'dailyInfo') {
      return 'dailyInfo';
    } else if (pathname === '/dashboard/rendaVariavel' && activeTutorial === 'variableIncome') {
      return 'variableIncome';
    }

    return null;
  }, [activeTutorial, pathname]);

  const setActiveTutorialForPage = useCallback((type: TutorialType | null) => {
    console.log('ðŸŽ¯ [TUTORIAL] Definindo tutorial ativo:', type);
    setActiveTutorial(type);
  }, []);

  const finishActiveTutorial = useCallback(() => {
    console.log('ðŸŽ¯ [TUTORIAL] Finalizando tutorial ativo:', activeTutorial);
    if (activeTutorial) {
      completeTutorial(activeTutorial);
      setActiveTutorial(null);
    }
  }, [activeTutorial, completeTutorial]);

  return {
    histData,
    mesesDisponiveis,
    showReplicateData,
    isLoadingData,
    dataFullyLoaded,
    hasCheckedBudgetData,
    setActiveTutorial: setActiveTutorialForPage,
    activeTutorial: getActiveTutorialForPage(),
    finishActiveTutorial,
    handleReplicateData,
    checkBudgetData,
    hasDataToReplicate: hasDataToReplicateSimple,
    shouldShowReplicateButton,
    retryAfterTokenRefresh
  };
}
