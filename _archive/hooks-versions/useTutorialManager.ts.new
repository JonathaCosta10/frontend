import { useState, useEffect, useCallback } from 'react';
import { useLocation } from 'react-router-dom';
import { useOnboarding } from './useOnboarding';
import { useAuth } from '../contexts/AuthContext';
import { api } from '../lib/api';
import DataCache from '../utils/DataCache';

// Tipo para os dados hist√≥ricos
export interface HistData {
  replicar_entradas: boolean;
  replicar_gastos: boolean;
  replicar_dividas: boolean;
  ultimo_registro_mes: number | null;
  ultimo_registro_ano: number | null;
}

// Tipo para a resposta da API de distribui√ß√£o de gastos
interface DistribuicaoGastosResponse {
  ano: string;
  meses_disponeis: string[];
  dados_mensais: Record<string, any>;
  metas_personalizadas: any;
  hist_data: HistData;
}

export type TutorialType = 'general' | 'dailyInfo' | 'budget' | 'variableIncome';

export function useTutorialManager() {
  const location = useLocation();
  const pathname = location.pathname;
  const { hasTutorialBeenCompleted, completeTutorial } = useOnboarding();
  const { isAuthenticated, user } = useAuth();
  
  const [activeTutorial, setActiveTutorial] = useState<TutorialType | null>(null);
  const [histData, setHistData] = useState<HistData | null>(null);
  const [mesesDisponiveis, setMesesDisponiveis] = useState<string[]>([]);
  const [showReplicateData, setShowReplicateData] = useState(false);
  const [isLoadingData, setIsLoadingData] = useState(false);
  const [hasCheckedBudgetData, setHasCheckedBudgetData] = useState(false);
  const [dataFullyLoaded, setDataFullyLoaded] = useState(false);
  const [lastSuccessfulLoad, setLastSuccessfulLoad] = useState<number>(0);
  const [buttonStateCache, setButtonStateCache] = useState<Record<string, boolean>>({});
  const [retryAfterTokenRefresh, setRetryAfterTokenRefresh] = useState(false);
  const [requestInProgress, setRequestInProgress] = useState<string | null>(null); // Cache para requisi√ß√µes em andamento

  // REGRA PRINCIPAL: Sistema est√° completamente vazio?
  const isSystemCompletelyEmpty = (data: HistData, mesesDisponiveis: string[]): boolean => {
    const noHistData = (
      data.replicar_entradas === false &&
      data.replicar_gastos === false &&
      data.replicar_dividas === false &&
      data.ultimo_registro_mes === null &&
      data.ultimo_registro_ano === null
    );
    
    const noAvailableMonths = mesesDisponiveis.length === 0;
    
    console.log('üéØ Verificando se sistema est√° completamente vazio:', {
      noHistData,
      noAvailableMonths,
      isEmpty: noHistData && noAvailableMonths,
      data,
      mesesDisponiveis
    });
    
    return noHistData && noAvailableMonths;
  };

  // REGRA: Tem dados hist√≥ricos para replicar?
  const hasDataToReplicate = (data: HistData, mesesDisponiveis: string[]): boolean => {
    const hasHistoricalData = (
      data.ultimo_registro_mes !== null &&
      data.ultimo_registro_ano !== null &&
      (data.replicar_entradas || data.replicar_gastos || data.replicar_dividas)
    );
    
    console.log('üîÑ Verificando se tem dados para replicar:', {
      hasHistoricalData,
      ultimo_registro_mes: data.ultimo_registro_mes,
      ultimo_registro_ano: data.ultimo_registro_ano,
      flags: {
        replicar_entradas: data.replicar_entradas,
        replicar_gastos: data.replicar_gastos,
        replicar_dividas: data.replicar_dividas
      }
    });
    
    return hasHistoricalData;
  };

  // Vers√£o simplificada da verifica√ß√£o de dados para replicar
  const hasDataToReplicateSimple = () => {
    return hasDataToReplicate(histData || {
      replicar_entradas: false,
      replicar_gastos: false,
      replicar_dividas: false,
      ultimo_registro_mes: null,
      ultimo_registro_ano: null
    }, mesesDisponiveis);
  };

  // FUN√á√ÉO PRINCIPAL: Decidir se mostra bot√£o de replica√ß√£o
  const shouldShowReplicateButton = useCallback((selectedMes?: string, selectedAno?: string) => {
    // CONDI√á√ÉO 0: Evitar verifica√ß√µes durante carregamento
    if (isLoadingData) {
      console.log('‚è≥ [BOT√ÉO REPLICA√á√ÉO] Aguardando carregamento...');
      return false;
    }
    
    // Cache key para evitar rec√°lculos desnecess√°rios
    const cacheKey = `${selectedMes || 'current'}-${selectedAno || 'current'}-${dataFullyLoaded}-${lastSuccessfulLoad}`;
    
    // Se j√° temos resultado em cache, usar diretamente
    if (buttonStateCache[cacheKey] !== undefined) {
      console.log('üíæ [BOT√ÉO REPLICA√á√ÉO] Usando cache:', { cacheKey, cached: buttonStateCache[cacheKey] });
      return buttonStateCache[cacheKey];
    }

    console.log('üîç [BOT√ÉO REPLICA√á√ÉO] Verificando condi√ß√µes...', {
      dataFullyLoaded,
      isLoadingData,
      hasHistData: !!histData,
      selectedMes,
      selectedAno,
      mesesDisponiveis,
      timestamp: new Date().toISOString()
    });

    // CONDI√á√ÉO 1: Dados devem estar COMPLETAMENTE carregados
    if (!dataFullyLoaded || !histData) {
      console.log('‚ùå [BOT√ÉO REPLICA√á√ÉO] FALHOU - Dados n√£o carregados', {
        dataFullyLoaded,
        hasHistData: !!histData,
        razao: !dataFullyLoaded ? 'dataFullyLoaded=false' : 'histData=null'
      });
      setButtonStateCache(prev => ({ ...prev, [cacheKey]: false }));
      return false;
    }

    // CONDI√á√ÉO 2: Deve ter dados hist√≥ricos para replicar
    const hasHistoricalData = hasDataToReplicate(histData, mesesDisponiveis);
    if (!hasHistoricalData) {
      console.log('‚ùå [BOT√ÉO REPLICA√á√ÉO] FALHOU - Sem dados hist√≥ricos v√°lidos');
      setButtonStateCache(prev => ({ ...prev, [cacheKey]: false }));
      return false;
    }

    // CONDI√á√ÉO 3: Se m√™s espec√≠fico foi fornecido, verificar se esse m√™s N√ÉO tem dados
    if (selectedMes) {
      const monthHasNoData = !mesesDisponiveis.includes(selectedMes);
      
      console.log('üéØ [BOT√ÉO REPLICA√á√ÉO] Verifica√ß√£o m√™s espec√≠fico:', {
        selectedMes,
        mesesDisponiveis,
        monthHasNoData,
        resultado: monthHasNoData ? 'MOSTRAR BOT√ÉO ‚úÖ' : 'N√ÉO MOSTRAR ‚ùå'
      });
      
      // Guardar resultado em cache para evitar rec√°lculos
      setButtonStateCache(prev => ({ ...prev, [cacheKey]: monthHasNoData }));
      return monthHasNoData;
    }

    // CONDI√á√ÉO 4: Verifica√ß√£o padr√£o para m√™s atual
    const currentDate = new Date();
    const currentMonthStr = (currentDate.getMonth() + 1).toString().padStart(2, '0');
    const shouldShow = !mesesDisponiveis.includes(currentMonthStr);
    
    console.log('üéØ [BOT√ÉO REPLICA√á√ÉO] Verifica√ß√£o m√™s atual:', {
      currentMonthStr,
      mesesDisponiveis,
      shouldShow,
      resultado: shouldShow ? 'MOSTRAR BOT√ÉO ‚úÖ' : 'N√ÉO MOSTRAR ‚ùå'
    });
    
    // Armazenar resultado no cache
    setButtonStateCache(prev => ({ ...prev, [cacheKey]: shouldShow }));
    return shouldShow;
  }, [dataFullyLoaded, isLoadingData, buttonStateCache, histData, mesesDisponiveis, lastSuccessfulLoad, hasDataToReplicate]);

  // Fun√ß√£o para buscar dados do or√ßamento
  const checkBudgetData = useCallback(async (year?: string, forceReload: boolean = false) => {
    const currentYear = year || new Date().getFullYear().toString();
    const requestKey = `budget-${currentYear}`;
    
    // Verificar se j√° h√° uma requisi√ß√£o em andamento para evitar duplicatas
    if (requestInProgress === requestKey && !forceReload) {
      console.log('‚è≥ Requisi√ß√£o j√° em andamento para:', requestKey);
      return;
    }
    
    if (isLoadingData && !forceReload) {
      console.log('‚è≥ J√° carregando dados...');
      return;
    }

    try {
      setRequestInProgress(requestKey);
      setIsLoadingData(true);
      setButtonStateCache({}); // Limpar cache antes de carregar novos dados
      
      console.log('üîç Buscando dados do or√ßamento para ano:', currentYear);
      
      // Tentar obter dados da API
      let data: DistribuicaoGastosResponse | null = null;
      let response;
      
      try {
        response = await api.get(`/api/distribuicao_gastos?ano=${currentYear}`);
        data = response.data as DistribuicaoGastosResponse;
        
        // Se deu certo, salvar no cache global
        if (data && data.hist_data) {
          DataCache.setBudgetData(currentYear, data);
        }
      } catch (innerError) {
        console.log('‚ö†Ô∏è [API ERROR] Erro na chamada inicial, tentando usar cache:', innerError);
        
        // Tentar usar o cache se dispon√≠vel
        data = DataCache.getBudgetData(currentYear) as DistribuicaoGastosResponse;
        
        if (!data) {
          // Se n√£o tiver cache, propagar o erro
          throw innerError;
        }
        
        console.log('‚úÖ [CACHE RECOVERY] Dados recuperados do cache com sucesso');
      }
      
      console.log('üìä [API SUCCESS] Dados recebidos:', {
        status: response?.status || 'no-status',
        data: data ? 'available' : 'undefined',
        timestamp: new Date().toISOString()
      });
      
      // CORRE√á√ÉO CR√çTICA: Verificar se data est√° definido e cont√©m dados v√°lidos
      if (!data) {
        throw new Error('Dados indispon√≠veis mesmo ap√≥s tentativa de recupera√ß√£o via cache');
      }
      
      // Atualizar os estados do componente com os dados recuperados
      setHistData(data.hist_data);
      setMesesDisponiveis(data.meses_disponeis || []);
      
      // Dados completamente carregados
      setHasCheckedBudgetData(true);
      setDataFullyLoaded(true);
      setLastSuccessfulLoad(Date.now());
      setRequestInProgress(null);
      setIsLoadingData(false);
      
      // Aplicar as regras de neg√≥cio ap√≥s obter dados
      if (data.hist_data && Array.isArray(data.meses_disponeis)) {
        const systemEmpty = isSystemCompletelyEmpty(data.hist_data, data.meses_disponeis || []);
        const hasReplicableData = hasDataToReplicate(data.hist_data, data.meses_disponeis || []);
        
        console.log('üîÑ Verifica√ß√£o de sistema para tutoriais:', { systemEmpty, hasReplicableData });
        
        // Se o sistema estiver vazio, n√£o mostrar o bot√£o de replica√ß√£o
        if (systemEmpty) {
          setShowReplicateData(false);
          
          if (pathname === '/dashboard/orcamento' && !hasTutorialBeenCompleted('budget')) {
            // Verificar se j√° completou o tutorial geral
            if (!hasTutorialBeenCompleted('general')) {
              setActiveTutorial('general');
            } else {
              setActiveTutorial('budget');
            }
          } else {
            setActiveTutorial(null);
          }
        }
        // Se tiver dados para replicar, mostrar o bot√£o
        else if (hasReplicableData) {
          setShowReplicateData(true);
          setActiveTutorial(null);
        }
      }
      
      return data; // Retornar os dados para quem chamou a fun√ß√£o
    } catch (error) {
      console.error('‚ùå [API ERROR] Erro ao buscar dados do or√ßamento:', error);
      
      // Em caso de erro, limpar a requisi√ß√£o em andamento e indicar que o carregamento terminou
      setRequestInProgress(null);
      setIsLoadingData(false);
      setDataFullyLoaded(false);
      setHasCheckedBudgetData(true);
      setRetryAfterTokenRefresh(true);
      
      return null;
    }
  }, [histData, isLoadingData, pathname, hasTutorialBeenCompleted, requestInProgress]);
  
  // FUN√á√ÉO: Replicar dados de um m√™s anterior para o m√™s atual
  const handleReplicateData = useCallback(async (fromMonth?: number, fromYear?: number) => {
    const today = new Date();
    const targetMonth = today.getMonth() + 1; // 1-12
    const targetYear = today.getFullYear();
    
    const sourceMonth = fromMonth || (histData?.ultimo_registro_mes || targetMonth);
    const sourceYear = fromYear || (histData?.ultimo_registro_ano || targetYear);
    
    console.log('üîÑ Replicando dados:', {
      de: { mes: sourceMonth, ano: sourceYear },
      para: { mes: targetMonth, ano: targetYear }
    });
    
    try {
      await api.post('/api/replicar_dados', {
        mes_origem: sourceMonth,
        ano_origem: sourceYear,
        mes_destino: targetMonth,
        ano_destino: targetYear
      });
      
      console.log('‚úÖ Dados replicados com sucesso!');
      
      // Atualizar a UI ap√≥s a replica√ß√£o
      checkBudgetData(String(targetYear), true);
      
      return true;
    } catch (error) {
      console.error('‚ùå Erro ao replicar dados:', error);
      return false;
    }
  }, [histData, checkBudgetData]);
  
  // Efeito para carregar dados iniciais
  useEffect(() => {
    const loadInitialData = async () => {
      console.log('üîÑ useEffect principal:', {
        pathname,
        hasCheckedBudgetData,
        isLoadingData,
        dataFullyLoaded
      });
      
      // S√≥ carregar dados do or√ßamento nas p√°ginas relacionadas
      if (pathname.startsWith('/dashboard/orcamento') || pathname === '/dashboard') {
        if (!hasCheckedBudgetData && !isLoadingData) {
          console.log('üîÑ Iniciando carregamento de dados do or√ßamento');
          
          // Verificar se temos ano espec√≠fico na URL
          const urlParams = new URLSearchParams(location.search);
          const anoParam = urlParams.get('ano');
          
          // Carregar dados para o ano especificado ou para o ano atual
          await checkBudgetData(anoParam || undefined);
        }
      }
    };
    
    if (isAuthenticated && user) {
      loadInitialData();
    }
  }, [isAuthenticated, user, pathname, hasCheckedBudgetData, isLoadingData, location.search, checkBudgetData]);
  
  // Monitorar token refresh para tentar novamente em caso de falhas por autentica√ß√£o
  useEffect(() => {
    // Apenas tentar novamente se estiver configurado para tal
    if (retryAfterTokenRefresh && pathname.startsWith('/dashboard/orcamento')) {
      console.log('üîÑ Tentando carregar dados novamente ap√≥s refresh de token');
      
      // Resetar o flag e tentar carregar os dados novamente
      setRetryAfterTokenRefresh(false);
      
      // Esperar um pouco antes de tentar novamente
      const timer = setTimeout(() => {
        checkBudgetData(undefined, true);
      }, 1000);
      
      return () => clearTimeout(timer);
    }
  }, [retryAfterTokenRefresh, pathname, checkBudgetData]);
  
  // Monitorar mudan√ßas de token para fazer retry
  useEffect(() => {
    console.log('üéØ [TOKEN LISTENER] Registrando listeners de token refresh:', {
      pathname,
      retryAfterTokenRefresh,
      timestamp: new Date().toISOString()
    });
    
    // Definir um contador de tentativas para evitar loops infinitos
    const retryCountKey = 'errorRetryCount';
    const currentRetries = parseInt(localStorage.getItem(retryCountKey) || '0');
    
    // AGGRESSIVE RETRY: Se ainda estiver na p√°gina de or√ßamento e tiver tokens atualizados, tentar novamente
    if (pathname.startsWith('/dashboard/orcamento') && currentRetries < 3) {
      localStorage.setItem(retryCountKey, String(currentRetries + 1));
      
      // Verificar se j√° tentamos v√°rias vezes e falhou
      if (currentRetries >= 2) {
        console.log('‚ö†Ô∏è [AGGRESSIVE RETRY] N√∫mero m√°ximo de tentativas atingido:', currentRetries);
        localStorage.removeItem(retryCountKey);
        return;
      }
      
      // Tentar novamente com delay
      const timer = setTimeout(() => {
        console.log('üîÑ [AGGRESSIVE RETRY] Tentativa', currentRetries + 1);
        
        // For√ßar atualiza√ß√£o apenas se precisar
        if (!dataFullyLoaded) {
          checkBudgetData(undefined, true);
        }
      }, 2000 * (currentRetries + 1)); // Backoff exponencial
      
      return () => clearTimeout(timer);
    } else if (!pathname.startsWith('/dashboard/orcamento')) {
      // Limpar contador de tentativas ao sair da p√°gina de or√ßamento
      localStorage.removeItem(retryCountKey);
    }
  }, [pathname, user, dataFullyLoaded, checkBudgetData]);
  
  // Fun√ß√£o para determinar qual tutorial deve estar ativo com base na URL atual
  const getActiveTutorialForPage = useCallback(() => {
    if (pathname === '/dashboard' && activeTutorial === 'general') {
      return 'general';
    } else if (pathname === '/dashboard/orcamento' && activeTutorial === 'budget') {
      return 'budget';
    } else if (pathname === '/dashboard/info' && activeTutorial === 'dailyInfo') {
      return 'dailyInfo';
    } else if (pathname === '/dashboard/rendaVariavel' && activeTutorial === 'variableIncome') {
      return 'variableIncome';
    }

    return null;
  }, [activeTutorial, pathname]);

  const setActiveTutorialForPage = useCallback((type: TutorialType | null) => {
    console.log('üéØ [TUTORIAL] Definindo tutorial ativo:', type);
    setActiveTutorial(type);
  }, []);

  const finishActiveTutorial = useCallback(() => {
    console.log('üéØ [TUTORIAL] Finalizando tutorial ativo:', activeTutorial);
    if (activeTutorial) {
      completeTutorial(activeTutorial);
      setActiveTutorial(null);
    }
  }, [activeTutorial, completeTutorial]);

  return {
    histData,
    mesesDisponiveis,
    showReplicateData,
    isLoadingData,
    dataFullyLoaded,
    hasCheckedBudgetData,
    setActiveTutorial: setActiveTutorialForPage,
    activeTutorial: getActiveTutorialForPage(),
    finishActiveTutorial,
    handleReplicateData,
    checkBudgetData,
    hasDataToReplicate: hasDataToReplicateSimple,
    shouldShowReplicateButton,
    retryAfterTokenRefresh
  };
}
