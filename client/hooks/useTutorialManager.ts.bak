import { useState, useEffect, useCallback } from 'react';
import { useLocation } from 'react-router-dom';
import { useOnboarding } from './useOnboarding';
import { useAuth } from '../contexts/AuthContext';
import { api } from '../lib/api';
import DataCache from '../utils/DataCache';

// Tipo para os dados hist√≥ricos
export interface HistData {
  replicar_entradas: boolean;
  replicar_gastos: boolean;
  replicar_dividas: boolean;
  ultimo_registro_mes: number | null;
  ultimo_registro_ano: number | null;
}

// Tipo para a resposta da API de distribui√ß√£o de gastos
interface DistribuicaoGastosResponse {
  ano: string;
  meses_disponeis: string[];
  dados_mensais: Record<string, any>;
  metas_personalizadas: any;
  hist_data: HistData;
}

export type TutorialType = 'general' | 'dailyInfo' | 'budget' | 'variableIncome';

export function useTutorialManager() {
  const location = useLocation();
  const pathname = location.pathname;
  const { hasTutorialBeenCompleted, completeTutorial } = useOnboarding();
  const { isAuthenticated, user } = useAuth();
  
  const [activeTutorial, setActiveTutorial] = useState<TutorialType | null>(null);
  const [histData, setHistData] = useState<HistData | null>(null);
  const [mesesDisponiveis, setMesesDisponiveis] = useState<string[]>([]);
  const [showReplicateData, setShowReplicateData] = useState(false);
  const [isLoadingData, setIsLoadingData] = useState(false);
  const [hasCheckedBudgetData, setHasCheckedBudgetData] = useState(false);
  const [dataFullyLoaded, setDataFullyLoaded] = useState(false);
  const [lastSuccessfulLoad, setLastSuccessfulLoad] = useState<number>(0);
  const [buttonStateCache, setButtonStateCache] = useState<Record<string, boolean>>({});
  const [retryAfterTokenRefresh, setRetryAfterTokenRefresh] = useState(false);
  const [requestInProgress, setRequestInProgress] = useState<string | null>(null); // Cache para requisi√ß√µes em andamento

  // REGRA PRINCIPAL: Sistema est√° completamente vazio?
  const isSystemCompletelyEmpty = (data: HistData, mesesDisponiveis: string[]): boolean => {
    const noHistData = (
      data.replicar_entradas === false &&
      data.replicar_gastos === false &&
      data.replicar_dividas === false &&
      data.ultimo_registro_mes === null &&
      data.ultimo_registro_ano === null
    );
    
    const noAvailableMonths = mesesDisponiveis.length === 0;
    
    console.log('üéØ Verificando se sistema est√° completamente vazio:', {
      noHistData,
      noAvailableMonths,
      isEmpty: noHistData && noAvailableMonths,
      data,
      mesesDisponiveis
    });
    
    return noHistData && noAvailableMonths;
  };

  // REGRA: Tem dados hist√≥ricos para replicar?
  const hasDataToReplicate = (data: HistData, mesesDisponiveis: string[]): boolean => {
    const hasHistoricalData = (
      data.ultimo_registro_mes !== null &&
      data.ultimo_registro_ano !== null &&
      (data.replicar_entradas || data.replicar_gastos || data.replicar_dividas)
    );
    
    console.log('üîÑ Verificando se tem dados para replicar:', {
      hasHistoricalData,
      ultimo_registro_mes: data.ultimo_registro_mes,
      ultimo_registro_ano: data.ultimo_registro_ano,
      flags: {
        replicar_entradas: data.replicar_entradas,
        replicar_gastos: data.replicar_gastos,
        replicar_dividas: data.replicar_dividas
      }
    });
    
    return hasHistoricalData;
  };

  // Vers√£o simplificada da verifica√ß√£o de dados para replicar
  const hasDataToReplicateSimple = () => {
    return hasDataToReplicate(histData || {
      replicar_entradas: false,
      replicar_gastos: false,
      replicar_dividas: false,
      ultimo_registro_mes: null,
      ultimo_registro_ano: null
    }, mesesDisponiveis);
  };

  // FUN√á√ÉO PRINCIPAL: Decidir se mostra bot√£o de replica√ß√£o
  const shouldShowReplicateButton = useCallback((selectedMes?: string, selectedAno?: string) => {
    // CONDI√á√ÉO 0: Evitar verifica√ß√µes durante carregamento
    if (isLoadingData) {
      console.log('‚è≥ [BOT√ÉO REPLICA√á√ÉO] Aguardando carregamento...');
      return false;
    }
    
    // Cache key para evitar rec√°lculos desnecess√°rios
    const cacheKey = `${selectedMes || 'current'}-${selectedAno || 'current'}-${dataFullyLoaded}-${lastSuccessfulLoad}`;
    
    // Se j√° temos resultado em cache, usar diretamente
    if (buttonStateCache[cacheKey] !== undefined) {
      console.log('üíæ [BOT√ÉO REPLICA√á√ÉO] Usando cache:', { cacheKey, cached: buttonStateCache[cacheKey] });
      return buttonStateCache[cacheKey];
    }

    console.log('üîç [BOT√ÉO REPLICA√á√ÉO] Verificando condi√ß√µes...', {
      dataFullyLoaded,
      isLoadingData,
      hasHistData: !!histData,
      selectedMes,
      selectedAno,
      mesesDisponiveis,
      timestamp: new Date().toISOString()
    });

    // CONDI√á√ÉO 1: Dados devem estar COMPLETAMENTE carregados
    if (!dataFullyLoaded || !histData) {
      console.log('‚ùå [BOT√ÉO REPLICA√á√ÉO] FALHOU - Dados n√£o carregados', {
        dataFullyLoaded,
        hasHistData: !!histData,
        razao: !dataFullyLoaded ? 'dataFullyLoaded=false' : 'histData=null'
      });
      setButtonStateCache(prev => ({ ...prev, [cacheKey]: false }));
      return false;
    }

    // CONDI√á√ÉO 2: Deve ter dados hist√≥ricos para replicar
    const hasHistoricalData = hasDataToReplicate(histData, mesesDisponiveis);
    if (!hasHistoricalData) {
      console.log('‚ùå [BOT√ÉO REPLICA√á√ÉO] FALHOU - Sem dados hist√≥ricos v√°lidos');
      setButtonStateCache(prev => ({ ...prev, [cacheKey]: false }));
      return false;
    }

    // CONDI√á√ÉO 3: Se m√™s espec√≠fico foi fornecido, verificar se esse m√™s N√ÉO tem dados
    if (selectedMes) {
      const monthHasNoData = !mesesDisponiveis.includes(selectedMes);
      
      console.log('üéØ [BOT√ÉO REPLICA√á√ÉO] Verifica√ß√£o m√™s espec√≠fico:', {
        selectedMes,
        mesesDisponiveis,
        monthHasNoData,
        resultado: monthHasNoData ? 'MOSTRAR BOT√ÉO ‚úÖ' : 'N√ÉO MOSTRAR ‚ùå'
      });
      
      // Guardar resultado em cache para evitar rec√°lculos
      setButtonStateCache(prev => ({ ...prev, [cacheKey]: monthHasNoData }));
      return monthHasNoData;
    }

    // CONDI√á√ÉO 4: Verifica√ß√£o padr√£o para m√™s atual
    const currentDate = new Date();
    const currentMonthStr = (currentDate.getMonth() + 1).toString().padStart(2, '0');
    const shouldShow = !mesesDisponiveis.includes(currentMonthStr);
    
    console.log('üéØ [BOT√ÉO REPLICA√á√ÉO] Verifica√ß√£o m√™s atual:', {
      currentMonthStr,
      mesesDisponiveis,
      shouldShow,
      resultado: shouldShow ? 'MOSTRAR BOT√ÉO ‚úÖ' : 'N√ÉO MOSTRAR ‚ùå'
    });
    
    // Armazenar resultado no cache
    setButtonStateCache(prev => ({ ...prev, [cacheKey]: shouldShow }));
    return shouldShow;
  }, [dataFullyLoaded, isLoadingData, buttonStateCache, histData, mesesDisponiveis, lastSuccessfulLoad, hasDataToReplicate]);
  };

  // Fun√ß√£o para buscar dados do or√ßamento
  const checkBudgetData = useCallback(async (year?: string, forceReload: boolean = false) => {
    const currentYear = year || new Date().getFullYear().toString();
    const requestKey = `budget-${currentYear}`;
    
    // Verificar se j√° h√° uma requisi√ß√£o em andamento para evitar duplicatas
    if (requestInProgress === requestKey && !forceReload) {
      console.log('‚è≥ Requisi√ß√£o j√° em andamento para:', requestKey);
      return;
    }
    
    if (isLoadingData && !forceReload) {
      console.log('‚è≥ J√° carregando dados...');
      return;
    }

    try {
      setRequestInProgress(requestKey);
      setIsLoadingData(true);
      setButtonStateCache({}); // Limpar cache antes de carregar novos dados
      
      console.log('üîç Buscando dados do or√ßamento para ano:', currentYear);
      
      // Tentar obter dados da API
      let data: DistribuicaoGastosResponse | null = null;
      let response;
      
      try {
        response = await api.get(`/api/distribuicao_gastos?ano=${currentYear}`);
        data = response.data as DistribuicaoGastosResponse;
        
        // Se deu certo, salvar no cache global
        if (data && data.hist_data) {
          DataCache.setBudgetData(currentYear, data);
        }
      } catch (innerError) {
        console.log('‚ö†Ô∏è [API ERROR] Erro na chamada inicial, tentando usar cache:', innerError);
        
        // Tentar usar o cache se dispon√≠vel
        data = DataCache.getBudgetData(currentYear) as DistribuicaoGastosResponse;
        
        if (!data) {
          // Se n√£o tiver cache, propagar o erro
          throw innerError;
        }
        
        console.log('‚úÖ [CACHE RECOVERY] Dados recuperados do cache com sucesso');
      }
      
      console.log('üìä [API SUCCESS] Dados recebidos:', {
        status: response?.status || 'no-status',
        data: data ? 'available' : 'undefined',
        timestamp: new Date().toISOString()
      });
      
      // CORRE√á√ÉO CR√çTICA: Verificar se data est√° definido e cont√©m dados v√°lidos
      if (!data) {
        console.log('‚ö†Ô∏è [API WARNING] Resposta recebida mas sem dados v√°lidos:', {
          hasData: false,
          responseKeys: [],
          timestamp: new Date().toISOString()
        });
        
        // Se n√£o houver dados, tentar usar cache ou considerar como erro
        throw new Error('Resposta sem dados - retry necess√°rio');
      }
      
      // Dados v√°lidos encontrados - atualizar estados
      console.log('‚úÖ [DADOS V√ÅLIDOS] Dados recebidos com sucesso:', {
        histData: data.hist_data,
        mesesDisponiveis: data.meses_disponeis || []
      });
      
      // Atualizar estados com os dados recebidos
      setHistData(data.hist_data);
      setMesesDisponiveis(data.meses_disponeis || []);
      
      console.log('‚úÖ [ESTADO ATUALIZADO] Dados processados:', {
        hist_data: data.hist_data,
        meses_disponeis: data.meses_disponeis
      });
      
      // Marcar dados como completamente carregados AP√ìS processamento
      setDataFullyLoaded(true);
      setLastSuccessfulLoad(Date.now());
      
      console.log('üéØ [DATA FULLY LOADED] Estado final:', {
        dataFullyLoaded: true,
          loadTimestamp: new Date().toISOString()
        });

        const systemEmpty = isSystemCompletelyEmpty(data.hist_data, data.meses_disponeis || []);
        const hasReplicableData = hasDataToReplicate(data.hist_data, data.meses_disponeis || []);
        
        // PRIORIDADE 1: Sistema vazio = Tutorial obrigat√≥rio
        if (systemEmpty) {
          console.log('üö® Sistema completamente vazio - Tutorial obrigat√≥rio!');
          setShowReplicateData(false);
          
          if (pathname === '/dashboard/orcamento' && !hasTutorialBeenCompleted('budget')) {
            console.log('üéì Iniciando tutorial para sistema vazio');
            if (!hasTutorialBeenCompleted('general')) {
              setActiveTutorial('general');
            } else {
              setActiveTutorial('budget');
            }
          }
        }
        // PRIORIDADE 2: Dados dispon√≠veis para replicar 
        else if (hasReplicableData) {
          console.log('üîÑ Dados hist√≥ricos dispon√≠veis para replica√ß√£o');
          setShowReplicateData(true);
          setActiveTutorial(null);
        }
        // PRIORIDADE 3: Sistema normal
        else {
          console.log('üìù Sistema normal - sem necessidade de tutorial ou replica√ß√£o');
          setShowReplicateData(false);
          setActiveTutorial(null);
        }
      // Marcar que os dados foram verificados
      setHasCheckedBudgetData(true);
    } catch (error: any) {
      console.error('‚ùå [API ERROR] Erro ao buscar dados:', error);
      
      // Sistema de limita√ß√£o de retentativas para prevenir loops infinitos
      const retryCountKey = 'errorRetryCount';
      const maxRetries = 3;
      const currentRetries = parseInt(localStorage.getItem(retryCountKey) || '0');
      
      if (currentRetries >= maxRetries) {
        console.log('üõë [RETRY LIMIT] M√°ximo de tentativas atingido:', {
          currentRetries,
          maxRetries,
          errorMessage: error.message
        });
        
        // Tentar usar dados de cache
        const cachedData = DataCache.getBudgetData(currentYear);
        if (cachedData) {
          console.log('‚úÖ [RETRY LIMIT] Usando dados de cache como fallback');
          // Processar dados do cache
          setHistData(cachedData.hist_data || {});
          setMesesDisponiveis(cachedData.meses_disponveis || []);
          setDataFullyLoaded(true);
          
          // Limpar flags para evitar novas tentativas
          localStorage.setItem(retryCountKey, '0');
          localStorage.removeItem('forceRetryAfterError');
          setRetryAfterTokenRefresh(false);
          setHasCheckedBudgetData(true);
          setIsLoadingData(false);
          
          return;
        }
        
        // Limpar flags para permitir nova tentativa ap√≥s algum tempo
        localStorage.setItem(retryCountKey, '0');
        localStorage.removeItem('forceRetryAfterError');
        setRetryAfterTokenRefresh(false);
        
        // Marcar verifica√ß√£o como conclu√≠da para parar tentativas autom√°ticas
        setHasCheckedBudgetData(true);
        setIsLoadingData(false);
        
        // Mostrar ao usu√°rio que estamos tendo problemas
        setDataFullyLoaded(false); // For√ßa o aplicativo a mostrar estado de erro
        
        // Exibir mensagem ao usu√°rio sobre o problema de conex√£o
        console.log('‚ö†Ô∏è [USER MESSAGE] Problemas de conex√£o com o servidor');
        
        return;
      }
      
      // Incrementar contador de tentativas
      const newRetryCount = currentRetries + 1;
      localStorage.setItem(retryCountKey, newRetryCount.toString());
      console.log('‚ö†Ô∏è [RETRY COUNTER] Incrementando contador:', {
        oldCount: currentRetries,
        newCount: newRetryCount,
        maxRetries
      });
      
      // ESTRAT√âGIA ROBUSTA com limite: Tentar novamente com retries limitados
      console.log('üîÑ [RETRY STRATEGY] Erro detectado - definindo retryAfterTokenRefresh com limite', {
        attempt: newRetryCount,
        maxAttempts: maxRetries
      });
      
      console.log('üîç [RETRY DEBUG] Detalhes do erro:', { 
        errorMessage: error.message,
        timestamp: new Date().toISOString()
      });
      
      // Definir flag universal de retry para QUALQUER erro
      localStorage.setItem('forceRetryAfterError', 'true');
      localStorage.setItem('lastErrorTimestamp', new Date().toISOString());
      
      // Garantir que retryAfterTokenRefresh seja TRUE
      setRetryAfterTokenRefresh(true);
      console.log('‚úÖ [RETRY] retryAfterTokenRefresh definido como TRUE');
      setHasCheckedBudgetData(false); // Permitir nova tentativa
      
      // SOLU√á√ÉO DE CONTORNO: Programar um retry ap√≥s intervalo progressivamente maior
      const retryDelay = 2000 + (currentRetries * 1000); // Aumenta o delay com cada tentativa
      setTimeout(() => {
        console.log('‚è±Ô∏è [ERROR RETRY] Executando retry ap√≥s intervalo:', {
          delay: retryDelay,
          attempt: newRetryCount
        });
        const currentYear = localStorage.getItem('ano') || new Date().getFullYear().toString();
        checkBudgetData(currentYear, true);
      }, retryDelay);
      
      // Em caso de erro, resetar estados
      setDataFullyLoaded(false);
      setHistData(null);
      setMesesDisponiveis([]);
      setShowReplicateData(false);
      setButtonStateCache({}); // Limpar cache
    } finally {
      setIsLoadingData(false);
      setRequestInProgress(null); // Limpar requisi√ß√£o em andamento
    }
  }, [pathname, hasTutorialBeenCompleted]);

  // useEffect espec√≠fico para reagir aos dados carregados
  useEffect(() => {
    if (dataFullyLoaded && histData) {
      console.log('‚úÖ [EFFECT] Dados completamente carregados - verificando replica√ß√£o:', {
        histData,
        mesesDisponiveis,
        dataFullyLoaded,
        timestamp: new Date().toISOString()
      });
    }
  }, [dataFullyLoaded, histData, mesesDisponiveis]);

  // useEffect principal - carregamento ordenado
  useEffect(() => {
    console.log('üîÑ useEffect principal:', {
      pathname,
      hasCheckedBudgetData,
      isLoadingData,
      dataFullyLoaded
    });
    
    // Resetar dados ao sair da p√°gina de or√ßamento
    if (pathname !== '/dashboard/orcamento' && dataFullyLoaded) {
      console.log('üîÑ Saindo da p√°gina de or√ßamento - resetando dados');
      setDataFullyLoaded(false);
      setHasCheckedBudgetData(false);
      setButtonStateCache({}); // Limpar cache ao sair
      localStorage.setItem('errorRetryCount', '0'); // Reset contador ao sair da p√°gina
      localStorage.removeItem('forceRetryAfterError'); // Limpar flag ao sair da p√°gina
    }
    
    // Detectar ciclo de retentativas e evitar loops
    const retryCount = parseInt(localStorage.getItem('errorRetryCount') || '0');
    const maxRetries = 3;
    if (retryCount >= maxRetries && pathname === '/dashboard/orcamento') {
      console.log('üõë [CYCLE DETECTION] Poss√≠vel loop detectado - evitando novas tentativas');
      setHasCheckedBudgetData(true);
      
      // Tentar usar dados de cache como √∫ltimo recurso
      const currentYear = localStorage.getItem('ano') || new Date().getFullYear().toString();
      const cachedData = DataCache.getBudgetData(currentYear);
      if (cachedData && !dataFullyLoaded) {
        console.log('üíæ [CYCLE RECOVERY] Usando dados de cache como fallback final');
        setHistData(cachedData.hist_data || {});
        setMesesDisponiveis(cachedData.meses_disponveis || []);
        setDataFullyLoaded(true);
      }
      return;
    }
    
    // Carregar dados na p√°gina de or√ßamento
    if (pathname === '/dashboard/orcamento' && !hasCheckedBudgetData && !isLoadingData) {
      const currentYear = localStorage.getItem('ano') || new Date().getFullYear().toString();
      checkBudgetData(currentYear);
      return;
    }
  }, [pathname, checkBudgetData, hasCheckedBudgetData, isLoadingData, dataFullyLoaded]);

  // useEffect para retry ap√≥s refresh do token
  useEffect(() => {
    if (retryAfterTokenRefresh && pathname === '/dashboard/orcamento' && !isLoadingData) {
      // Verificar se n√£o excedeu o n√∫mero m√°ximo de tentativas
      const retryCountKey = 'errorRetryCount';
      const maxRetries = 3;
      const currentRetries = parseInt(localStorage.getItem(retryCountKey) || '0');
      
      if (currentRetries >= maxRetries) {
        console.log('‚õî [RETRY BLOCKED] M√°ximo de tentativas j√° atingido:', {
          currentRetries,
          maxRetries,
          action: 'retry cancelado'
        });
        setRetryAfterTokenRefresh(false);
        return;
      }
      
      console.log('üîÑ [RETRY] Token atualizado - tentando carregar dados novamente');
      setRetryAfterTokenRefresh(false);
      const currentYear = localStorage.getItem('ano') || new Date().getFullYear().toString();
      
      // Pequeno delay para garantir que o token foi processado
      setTimeout(() => {
        console.log('‚ö° [FORCED RETRY] Executando retry for√ßado ap√≥s token refresh');
        checkBudgetData(currentYear, true);
      }, 500);
    }
  }, [retryAfterTokenRefresh, pathname, isLoadingData, checkBudgetData]);
  
  // NOVA SOLU√á√ÉO: Retry autom√°tico agressivo para garantir carregamento
  useEffect(() => {
    // N√£o fazer nada se n√£o estamos na p√°gina de or√ßamento
    if (pathname !== '/dashboard/orcamento') {
      return;
    }
  
    // Controle de tentativas para prevenir loops infinitos
    const maxAttempts = 3;
    const attemptKey = 'aggressiveRetryAttempts';
    const currentAttempts = parseInt(localStorage.getItem(attemptKey) || '0');
    
    if (currentAttempts >= maxAttempts) {
      console.log('‚ö†Ô∏è [AGGRESSIVE RETRY] N√∫mero m√°ximo de tentativas atingido:', currentAttempts);
      return;
    }
    
    console.log('‚ö° [AGGRESSIVE RETRY] P√°gina de or√ßamento detectada - configurando retry agressivo', {
      currentAttempts,
      maxAttempts,
      dataFullyLoaded,
      isLoadingData
    });
    
    // Incrementar contador de tentativas
    localStorage.setItem(attemptKey, (currentAttempts + 1).toString());
    
    // Reset do contador ap√≥s 30 segundos para permitir novas tentativas no futuro
    setTimeout(() => {
      localStorage.setItem(attemptKey, '0');
    }, 30000);
    
    // SOLU√á√ÉO 1: Verifica√ß√£o inicial ap√≥s delay maior
    const initialRetryTimeout = setTimeout(() => {
      // Verificar se ainda estamos na p√°gina de or√ßamento
      if (pathname !== '/dashboard/orcamento') {
        console.log('‚ö†Ô∏è [AGGRESSIVE RETRY] P√°gina mudou, cancelando retry');
        return;
      }
      
      // Verificar se j√° existe uma flag de erro para evitar retry em loops
      if (localStorage.getItem('errorRetryCount') && 
          parseInt(localStorage.getItem('errorRetryCount') || '0') >= 2) {
        console.log('üö´ [AGGRESSIVE RETRY] Ignorando retry devido a erros recentes');
        return;
      }
      
      if (!dataFullyLoaded && !isLoadingData) {
        console.log('üö® [AGGRESSIVE RETRY] Dados n√£o carregados - RETRY √öNICO');
        const currentYear = localStorage.getItem('ano') || new Date().getFullYear().toString();
        // For√ßar retry mas apenas uma vez
        setRetryAfterTokenRefresh(true);
        checkBudgetData(currentYear, true);
      } else {
        console.log('‚úÖ [AGGRESSIVE RETRY] Dados j√° carregados - ignorando');
      }
    }, 3000); // Delay maior para dar tempo aos outros processos
    
    // SOLU√á√ÉO 2: Verifica√ß√£o peri√≥dica √∫nica em vez de interval
    // Isso evita m√∫ltiplas chamadas simult√¢neas que podem causar loops
    const checkDataTimeout = setTimeout(() => {
      console.log('‚è±Ô∏è [PERIODIC CHECK] Verificando se dados est√£o carregados...', {
        dataFullyLoaded,
        isLoadingData,
        showReplicateData,
        hasHistData: !!histData
      });
      
      // Verificar se j√° existe uma flag de erro para evitar retry em loops
      if (localStorage.getItem('errorRetryCount') && 
          parseInt(localStorage.getItem('errorRetryCount') || '0') >= 2) {
        console.log('üö´ [PERIODIC CHECK] Ignorando retry devido a erros recentes');
        return;
      }
      
      // Se ainda n√£o carregou completamente, tentar novamente
      if (!dataFullyLoaded && !isLoadingData) {
        console.log('üîÑ [PERIODIC CHECK] Dados ainda n√£o carregados - for√ßando retry');
        const currentYear = localStorage.getItem('ano') || new Date().getFullYear().toString();
        checkBudgetData(currentYear, true);
      } else if (dataFullyLoaded) {
        console.log('‚úÖ [PERIODIC CHECK] Dados carregados com sucesso');
      }
    }, 5000); // Verificar ap√≥s 5 segundos para dar mais tempo
    
    return () => {
      clearTimeout(initialRetryTimeout);
      clearTimeout(checkDataTimeout);
      // Limpar qualquer outra refer√™ncia de timeout
    };
  }, [pathname, dataFullyLoaded, isLoadingData, checkBudgetData]);

  // Limpar os flags de bot√µes processados quando os dados mudarem
  useEffect(() => {
    if (dataFullyLoaded) {
      console.log('üßπ [BOT√ÉO DELAY] Limpando flags de bot√µes processados ap√≥s dados carregados');
      
      // Buscar e limpar todas as chaves de bot√µes processados
      Object.keys(localStorage).forEach(key => {
        if (key.startsWith('processed-')) {
          localStorage.removeItem(key);
        }
      });
    }
  }, [dataFullyLoaded]);

  // useEffect para escutar eventos de atualiza√ß√£o de token
  useEffect(() => {
    console.log('üéØ [TOKEN LISTENER] Registrando listeners de token refresh:', { 
      pathname, 
      retryAfterTokenRefresh, 
      timestamp: new Date().toISOString() 
    });
    
    const handleTokenRefresh = () => {
      console.log('üîÑ [TOKEN REFRESH EVENT] Detectado - tentando carregar dados');
      if (pathname === '/dashboard/orcamento' && retryAfterTokenRefresh) {
        console.log('‚úÖ [TOKEN REFRESH] Condi√ß√µes atendidas - executando retry');
        setRetryAfterTokenRefresh(false);
        const currentYear = localStorage.getItem('ano') || new Date().getFullYear().toString();
        setTimeout(() => {
          checkBudgetData(currentYear, true);
        }, 1000);
      } else {
        console.log('‚ùå [TOKEN REFRESH] Condi√ß√µes n√£o atendidas:', { 
          pathname, 
          retryAfterTokenRefresh, 
          isOrcamentoPage: pathname === '/dashboard/orcamento' 
        });
      }
    };

    // Escutar eventos de storage para detectar mudan√ßas no token
    const handleStorageToken = (e: StorageEvent) => {
      if (e.key === 'authToken' && e.newValue && pathname === '/dashboard/orcamento' && retryAfterTokenRefresh) {
        console.log('üîë [TOKEN STORAGE] Novo token detectado via storage event');
        handleTokenRefresh();
      }
    };

    // Customizando o comportamento do token refresh
    const handleCustomTokenRefresh = () => {
      console.log('üîë [CUSTOM TOKEN REFRESH] Evento customizado detectado');
      if (pathname === '/dashboard/orcamento') {
        console.log('‚úÖ [CUSTOM TOKEN REFRESH] Na p√°gina de or√ßamento - verificando condi√ß√µes');
        
        // Verificar se deve fazer retry baseado na flag universal
        const shouldRetry = localStorage.getItem('forceRetryAfterError') === 'true';
        
        // Verificar contador de tentativas para prevenir loops
        const retryCount = parseInt(localStorage.getItem('errorRetryCount') || '0');
        const maxRetries = 3;
        
        console.log('üîç [CUSTOM TOKEN REFRESH] Verificando necessidade de retry:', {
          shouldRetry,
          pathname,
          retryAfterTokenRefresh,
          retryCount,
          maxRetries,
          forceRetryAfterError: localStorage.getItem('forceRetryAfterError'),
          lastErrorTimestamp: localStorage.getItem('lastErrorTimestamp')
        });
        
        // Verificar se dataFullyLoaded j√° foi estabelecido - evita retries desnecess√°rios
        if (dataFullyLoaded) {
          console.log('‚úÖ [CUSTOM TOKEN REFRESH] Dados j√° carregados, ignorando retry');
          localStorage.removeItem('forceRetryAfterError');
          localStorage.setItem('errorRetryCount', '0');
          return false;
        }
        
        if (shouldRetry && retryCount < maxRetries) {
          console.log('‚úÖ [CUSTOM TOKEN REFRESH] Retry autorizado - executando ap√≥s delay');
          localStorage.removeItem('forceRetryAfterError'); // Limpar para evitar loops
          
          // Incrementar contador para acompanhar tentativas no token refresh
          localStorage.setItem('errorRetryCount', (retryCount + 1).toString());
          
          // Incluir delay progressivo baseado no n√∫mero de tentativas
          const delay = 1500 + (retryCount * 500);
          
          setTimeout(() => {
            const currentYear = localStorage.getItem('ano') || new Date().getFullYear().toString();
            console.log('‚ö° [CUSTOM TOKEN REFRESH] Executando retry com ano:', currentYear, {
              tentativa: retryCount + 1,
              delay
            });
            setHasCheckedBudgetData(false);
            checkBudgetData(currentYear, true);
          }, delay);
          
          return true;
        } else if (retryCount >= maxRetries) {
          console.log('üõë [CUSTOM TOKEN REFRESH] M√°ximo de tentativas atingido:', {
            retryCount,
            maxRetries
          });
          // Limpar flag para permitir tentativas futuras
          localStorage.removeItem('forceRetryAfterError');
          
          // Reset do contador ap√≥s limite para permitir novas tentativas no futuro
          // mas s√≥ depois de um per√≠odo maior
          setTimeout(() => {
            localStorage.setItem('errorRetryCount', '0');
          }, 10000);
        }
      }
      
      return false;
    };
    
    // Registrando eventos customizados
    window.addEventListener('storage', handleStorageToken);
    window.addEventListener('authTokenRefreshed', handleTokenRefresh);
    
    // Expor fun√ß√£o customizada globalmente para uso em interceptores
    (window as any).handleTokenRefreshAndRetry = handleCustomTokenRefresh;
    
    return () => {
      // Remover listeners ao desmontar componente
      window.removeEventListener('storage', handleStorageToken);
      window.removeEventListener('authTokenRefreshed', handleTokenRefresh);
      
      // Remover fun√ß√£o global ao desmontar
      delete (window as any).handleTokenRefreshAndRetry;
    };
  }, [pathname, retryAfterTokenRefresh, checkBudgetData]);

  const handleReplicateData = useCallback(async (mes: string, ano: string) => {
    console.log('üîÑ Solicitando replica√ß√£o de dados:', { mes, ano });
  }, []);

  const getActiveTutorialForPage = useCallback(() => {
    const isGeneralTutorialActive = activeTutorial === 'general';
    const isBudgetTutorialActive = activeTutorial === 'budget';

    console.log('üéØ [TUTORIAL] Verificando tutorial ativo:', { 
      activeTutorial, 
      path: pathname,
      isGeneralTutorialActive,
      isBudgetTutorialActive
    });

    if (pathname === '/dashboard/orcamento') {
      if (isGeneralTutorialActive) {
        return 'general';
      } else if (isBudgetTutorialActive) {
        return 'budget';
      }
    } else if (pathname === '/dashboard/diario' && activeTutorial === 'dailyInfo') {
      return 'dailyInfo';
    } else if (pathname === '/dashboard/rendaVariavel' && activeTutorial === 'variableIncome') {
      return 'variableIncome';
    }

    return null;
  }, [activeTutorial, pathname]);

  const setActiveTutorialForPage = useCallback((type: TutorialType | null) => {
    console.log('üéØ [TUTORIAL] Definindo tutorial ativo:', type);
    setActiveTutorial(type);
  }, []);

  const finishActiveTutorial = useCallback(() => {
    console.log('üéØ [TUTORIAL] Finalizando tutorial ativo:', activeTutorial);
    if (activeTutorial) {
      completeTutorial(activeTutorial);
      setActiveTutorial(null);
    }
  }, [activeTutorial, completeTutorial]);

  return {
    histData,
    mesesDisponiveis,
    showReplicateData,
    isLoadingData,
    dataFullyLoaded,
    hasCheckedBudgetData,
    setActiveTutorial: setActiveTutorialForPage,
    activeTutorial: getActiveTutorialForPage(),
    finishActiveTutorial,
    handleReplicateData,
    checkBudgetData,
    hasDataToReplicate: hasDataToReplicateSimple,
    shouldShowReplicateButton,
    retryAfterTokenRefresh
  };
}