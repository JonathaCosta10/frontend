import { localStorageManager } from "./localStorage";

// Configura√ß√£o centralizada para URLs da API
const BACKEND_URL = import.meta.env.VITE_BACKEND_URL || 
                   import.meta.env.VITE_API_BASE_URL || 
                   import.meta.env.VITE_API_URL || 
                   "http://127.0.0.1:5000";
const API_KEY = import.meta.env.VITE_API_KEY || "}$gQ7TlDEhJ88np]^n8[uFu{9f#;+8qjZ&?c[+Sj_CLhMO[Z(iM_)ZnW]j2M]+j+";

console.log('üîß Configura√ß√£o da API:', {
  BACKEND_URL,
  VITE_BACKEND_URL: import.meta.env.VITE_BACKEND_URL,
  VITE_API_BASE_URL: import.meta.env.VITE_API_BASE_URL,
  VITE_API_URL: import.meta.env.VITE_API_URL,
  API_KEY: API_KEY?.substring(0, 10) + '...'
});

// Tratamento para consist√™ncia de URLs
const normalizeUrl = (url: string): string => {
  const isProd = typeof window !== 'undefined' && (
    window.location.hostname.includes('organizesee.com.br') || 
    window.location.hostname.includes('www.organizesee.com.br')
  );
  
  // Log para depura√ß√£o de URLs
  console.log("üîÑ Normalizando URL:", { 
    url, 
    backendUrl: BACKEND_URL, 
    isProd,
    hostname: typeof window !== 'undefined' ? window.location.hostname : 'unknown'
  });

  // Se a URL j√° √© absoluta com https, manter como est√°
  if (url.startsWith('https://')) {
    // Verificar se √© uma URL para o backend sem /services/api/ em produ√ß√£o
    if (isProd && 
        url.startsWith('https://backend.organizesee.com.br/api/') && 
        !url.includes('/services/api/')) {
      // Converter de /api/ para /services/api/
      const correctedUrl = url.replace('/api/', '/services/api/');
      console.log("üìç URL absoluta corrigida para produ√ß√£o:", correctedUrl);
      return correctedUrl;
    }
    return url;
  }
  
  // URLs relativas come√ßando com /api/ em ambiente de produ√ß√£o
  if (url.startsWith('/api/') && isProd) {
    const prodUrl = `https://www.organizesee.com.br/services/api${url.substring(4)}`;
    console.log("üìç URL corrigida para produ√ß√£o:", prodUrl);
    return prodUrl;
  }
  
  // Para desenvolvimento local - manter formato /api/
  if (url.startsWith('/api/') && (BACKEND_URL.includes('127.0.0.1') || BACKEND_URL.includes('localhost'))) {
    const devUrl = `${BACKEND_URL}${url}`;
    console.log("üìç URL para desenvolvimento:", devUrl);
    return devUrl;
  }
  
  // Para URLs que come√ßam com /investimentos/ em produ√ß√£o
  if (url.startsWith('/investimentos/') && isProd) {
    const prodUrl = `https://www.organizesee.com.br/services/api${url}`;
    console.log("üìç URL de investimentos corrigida para produ√ß√£o:", prodUrl);
    return prodUrl;
  }
  
  // Normalizar URLs que come√ßam com /api/ para usar /services/api/ em ambiente n√£o local
  if (url.startsWith('/api/') && !BACKEND_URL.includes('127.0.0.1') && !BACKEND_URL.includes('localhost')) {
    const servicePath = `/services/api${url.substring(4)}`;
    const fullUrl = `${BACKEND_URL}${servicePath}`;
    console.log("üìç URL normalizada com services:", fullUrl);
    return fullUrl;
  }
  
  // Caso padr√£o: concatenar BACKEND_URL com a URL
  const standardUrl = `${BACKEND_URL}${url.startsWith('/') ? '' : '/'}${url}`;
  console.log("üìç URL padr√£o:", standardUrl);
  return standardUrl;
};

interface ExtendedRequestInit extends RequestInit {
  authenticated?: boolean;
  skipRefresh?: boolean;
}

interface ApiError extends Error {
  status?: number;
  code?: string;
  details?: any;
}

// Extender interface Window global para incluir m√©todos personalizados
declare global {
  interface Window {
    handleTokenRefreshAndRetry?: () => boolean;
  }
}

export class ApiService {
  private static instance: ApiService;
  private refreshPromise: Promise<boolean> | null = null;

  static getInstance(): ApiService {
    if (!ApiService.instance) {
      ApiService.instance = new ApiService();
    }
    return ApiService.instance;
  }

  /**
   * Construir headers com autentica√ß√£o JWT
   */
  private buildHeaders(
    customHeaders: HeadersInit = {},
    includeAuth: boolean = false,
    skipCustomHeaders: boolean = false,
  ): HeadersInit {
    const headers: HeadersInit = {
      "Content-Type": "application/json",
      "X-API-Key": API_KEY,
      "X-Client-Version": localStorageManager.getAppVersion() || "1.0.0",
      "X-Requested-With": "XMLHttpRequest", // Header permitido pelo backend
      ...customHeaders,
    };

    // CORS Fix: N√£o adicionar headers problem√°ticos para refresh token
    if (!skipCustomHeaders) {
      // Comentado para evitar erro CORS no refresh token
      // const sessionId = localStorageManager.getSessionId();
      // if (sessionId) {
      //   headers["X-Session-ID"] = sessionId;
      // }
      // const fingerprint = localStorageManager.getDeviceFingerprint();
      // if (fingerprint) {
      //   headers["X-Device-ID"] = fingerprint.hash;
      // }
    }

    if (includeAuth) {
      const token = localStorageManager.getAuthToken();
      if (token) {
        headers["Authorization"] = `Bearer ${token}`;
      }
    }

    return headers;
  }

  /**
   * Validar token JWT antes de fazer requisi√ß√£o
   */
  private isTokenValid(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split(".")[1]));
      const now = Math.floor(Date.now() / 1000);

      // Verificar se token est√° prestes a expirar (em 1 minuto)
      if (payload.exp - now < 60) {
        return false;
      }

      // Validar campos obrigat√≥rios
      if (!payload.user_id || !payload.email) {
        return false;
      }

      return payload.exp > now;
    } catch {
      return false;
    }
  }

  /**
   * M√©todo principal para requisi√ß√µes com seguran√ßa JWT
   */
  async request(
    endpoint: string,
    options: ExtendedRequestInit = {},
  ): Promise<any> {
    const normalizedUrl = normalizeUrl(endpoint);
    const includeAuth = options.authenticated ?? false;

    // Log para debug da URL normalizada
    if (import.meta.env.DEV || endpoint.includes("login") || endpoint.includes("refresh")) {
      console.log(`üîó Request: ${normalizedUrl}`, { 
        original: endpoint, 
        isAuth: includeAuth 
      });
    }

    // Validar token se autentica√ß√£o necess√°ria
    if (includeAuth) {
      const token = localStorageManager.getAuthToken();
      if (!token || !this.isTokenValid(token)) {
        console.log("Token inv√°lido ou expirado detectado");

        if (!options.skipRefresh) {
          const refreshed = await this.refreshToken();
          if (!refreshed) {
            this.handleAuthFailure();
            const error = new Error("Authentication failed") as ApiError;
            error.status = 401;
            error.code = "AUTH_FAILED";
            throw error;
          }
        }
      }
    }

    // CORS Fix: Detectar refresh token para evitar headers problem√°ticos
    const isRefreshTokenRequest = endpoint.includes("/token/refresh/");
    const headers = this.buildHeaders(
      options.headers || {},
      includeAuth,
      isRefreshTokenRequest,
    );
    const { authenticated, skipRefresh, ...fetchOptions } = options;

    // Gerenciamento de timeout adaptativo - mais tempo para requisi√ß√µes importantes
    const timeoutDuration = isRefreshTokenRequest ? 30000 : 
                            endpoint.includes("/distribuicao_gastos") ? 25000 : 
                            endpoint.includes("/auth/") ? 20000 : 
                            endpoint.includes("/login") ? 30000 : 15000;
    
    console.log(`‚è±Ô∏è [REQUEST TIMEOUT] Configurando timeout para ${endpoint}:`, {
      duration: timeoutDuration,
      isRefresh: isRefreshTokenRequest,
      isAuth: includeAuth,
      endpoint
    });
    
    const config: RequestInit = {
      ...fetchOptions,
      headers
      // N√£o configuramos signal aqui - ser√° feito via AbortController
    };

    try {
      let response;
      
      // Criando um novo AbortController para melhor gerenciamento de erros
      const requestController = new AbortController();
      const requestTimeout = setTimeout(() => {
        requestController.abort('timeout');
      }, timeoutDuration);
      
      // Sobrescrever o signal do config para usar o controller customizado
      const requestConfig = {
        ...config,
        signal: requestController.signal
      };
      
      try {
        response = await fetch(normalizedUrl, requestConfig);
        clearTimeout(requestTimeout); // Limpar timeout se a resposta for recebida
      
        // Tratar 401 Unauthorized
        if (
          response.status === 401 &&
          includeAuth &&
          !options.skipRefresh &&
          this.hasRefreshToken() &&
          !this.isRefreshEndpoint(endpoint)
        ) {
          console.log("Recebido 401, tentando refresh do token");

          const refreshed = await this.refreshToken();
          if (refreshed) {
            // Criar novo controller para nova tentativa
            const retryController = new AbortController();
            const retryTimeout = setTimeout(() => {
              retryController.abort('timeout');
            }, timeoutDuration);
            
            // Repetir com novo token usando a URL normalizada
            const newHeaders = this.buildHeaders(options.headers || {}, true);
            try {
              response = await fetch(normalizedUrl, { 
                ...requestConfig, 
                headers: newHeaders,
                signal: retryController.signal 
              });
              clearTimeout(retryTimeout);
            } catch (retryError) {
              clearTimeout(retryTimeout);
              throw retryError;
            }
          } else {
            this.handleAuthFailure();
            const error = new Error(
              "Authentication failed after refresh",
            ) as ApiError;
            error.status = 401;
            error.code = "AUTH_REFRESH_FAILED";
            throw error;
          }
        }
      } catch (fetchError) {
        clearTimeout(requestTimeout);
        throw fetchError;
      }

      // Status 204 (No Content) √© sucesso para DELETE, mas response.ok √© false
      if (!response.ok && response.status !== 204) {
        const errorData = await response.json().catch(() => ({}));
        const error = new Error(
          errorData.detail || errorData.message || `HTTP ${response.status}`,
        ) as ApiError;
        error.status = response.status;
        error.code = errorData.code || `HTTP_${response.status}`;
        error.details = errorData;

        console.error("API request failed", {
          endpoint,
          status: response.status,
          code: error.code,
        });

        throw error;
      }

      // Para status 204 (No Content), retornar objeto vazio
      if (response.status === 204) {
        return {};
      }

      const contentType = response.headers.get("content-type");
      if (contentType?.includes("application/json")) {
        return await response.json();
      }

      return response;
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        console.error("Request timeout", { endpoint });
        const timeoutError = new Error("Request timeout") as ApiError;
        timeoutError.status = 408;
        timeoutError.code = "TIMEOUT";
        throw timeoutError;
      }

      // Re-lan√ßar ApiErrors como est√£o
      if ((error as ApiError).status) {
        throw error;
      }

      // Erros de rede ou outros
      console.error("Network error", {
        endpoint,
        error: (error as Error).message,
      });
      const networkError = new Error("Network error occurred") as ApiError;
      networkError.status = 0;
      networkError.code = "NETWORK_ERROR";
      throw networkError;
    }
  }

  /**
   * Wrapper para requisi√ß√µes autenticadas
   */
  async authenticatedRequest(
    endpoint: string,
    options: RequestInit = {},
  ): Promise<any> {
    return this.request(endpoint, { ...options, authenticated: true });
  }

  /**
   * Refresh de token com padr√£o singleton para prevenir m√∫ltiplos refreshes simult√¢neos
   */
  private async refreshToken(): Promise<boolean> {
    if (this.refreshPromise) {
      return this.refreshPromise;
    }

    this.refreshPromise = this.performTokenRefresh();
    const result = await this.refreshPromise;
    this.refreshPromise = null;

    return result;
  }

  /**
   * Executar refresh real do token
   */
  private async performTokenRefresh(): Promise<boolean> {
    // Prevenir m√∫ltiplos refreshes em curto per√≠odo de tempo - RELAXAR PARA LOGIN
    const lastRefreshKey = 'lastTokenRefreshAttempt';
    const lastRefreshTime = parseInt(localStorage.getItem(lastRefreshKey) || '0');
    const currentTime = Date.now();
    const minRefreshInterval = 2000; // Reduzido para 2 segundos para permitir fluxos de login
    
    // Se um login acabou de ser realizado, n√£o bloquear o refresh
    const recentLoginAttempt = localStorage.getItem('recentLoginAttempt');
    const isPostLogin = recentLoginAttempt && (currentTime - parseInt(recentLoginAttempt)) < 10000;
    
    if (currentTime - lastRefreshTime < minRefreshInterval && !isPostLogin) {
      console.log("‚ö†Ô∏è [TOKEN REFRESH] Tentativas muito frequentes, aguardando intervalo m√≠nimo", {
        lastAttempt: new Date(lastRefreshTime).toISOString(),
        currentTime: new Date(currentTime).toISOString(),
        timeDiff: currentTime - lastRefreshTime,
        minInterval: minRefreshInterval,
        isPostLogin
      });
      await new Promise(resolve => setTimeout(resolve, 500)); // Reduzido para n√£o atrasar tanto
      return true; // Tentar mesmo assim ap√≥s o delay, para n√£o bloquear login
    }
    
    // Registrar tentativa atual
    localStorage.setItem(lastRefreshKey, currentTime.toString());
    
    // Sistema de controle de tentativas
    const refreshCountKey = 'tokenRefreshAttemptCount';
    const maxAttempts = 3;
    const currentAttempts = parseInt(localStorage.getItem(refreshCountKey) || '0');
    
    if (currentAttempts >= maxAttempts) {
      console.log("üõë [TOKEN REFRESH] M√°ximo de tentativas atingido:", {
        currentAttempts,
        maxAttempts
      });
      
      // Reset do contador ap√≥s 30 segundos para permitir novas tentativas
      setTimeout(() => {
        localStorage.setItem(refreshCountKey, '0');
      }, 30000);
      
      return false;
    }
    
    // Incrementar contador
    localStorage.setItem(refreshCountKey, (currentAttempts + 1).toString());
    console.log(`‚ö†Ô∏è [TOKEN REFRESH] Tentativa ${currentAttempts + 1}/${maxAttempts}`);

    try {
      const refreshToken = localStorageManager.getRefreshToken();
      if (!refreshToken) {
        console.log("Nenhum refresh token dispon√≠vel");
        return false;
      }

      console.log("Tentando refresh do token");

      // Criar controller para timeout mais longo para refresh
      const controller = new AbortController();
      const timeoutId = setTimeout(() => {
        controller.abort('timeout');
      }, 30000);

      try {
        // Usar fetch direto para refresh para evitar loops
        const response = await fetch(normalizeUrl("/api/auth/token/refresh/"), {
          method: "POST",
          headers: this.buildHeaders({}, false, true),
          body: JSON.stringify({ refresh: refreshToken }),
          signal: controller.signal
        })
        .then(res => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        });
        
        clearTimeout(timeoutId);

        if (!response.access) {
          throw new Error("Resposta de refresh inv√°lida");
        }

        // Processar resposta completa atrav√©s do ResponseParms
        const { responseParms } = await import('../contexts/ResponseParms');
        console.log("üîÑ Processando refresh token atrav√©s do ResponseParms");
        console.log("üîç Dados recebidos do refresh:", response);
        
        // Simular estrutura de resposta da API para processamento
        const apiResponse = {
          success: true,
          data: response,
          status: 200,
          message: "Refresh token bem-sucedido"
        };
        
        responseParms.processResponse({
          response: apiResponse,
          chave: "refreshToken",
          method: "POST",
          endpoint: "/api/auth/token/refresh/",
          withAuth: true
        });
        
        // Reset do contador de tentativas ap√≥s sucesso
        localStorage.setItem(refreshCountKey, '0');
        
        // CORRE√á√ÉO CR√çTICA: Disparar eventos para notificar componentes do refresh
        console.log("‚úÖ Refresh do token bem-sucedido - emitindo eventos");
        
        // Evento padr√£o
        const tokenRefreshEvent = new CustomEvent('tokenRefreshed', { 
          detail: { 
            timestamp: new Date().toISOString(),
            success: true 
          } 
        });
        console.log("üöÄ [TOKEN EVENT] Disparando evento tokenRefreshed:", tokenRefreshEvent.detail);
        window.dispatchEvent(tokenRefreshEvent);
        
        // Evento de autentica√ß√£o
        const authEvent = new CustomEvent('authTokenRefreshed', { 
          detail: { 
            timestamp: new Date().toISOString()
          } 
        });
        console.log("üöÄ [TOKEN EVENT] Disparando evento authTokenRefreshed");
        window.dispatchEvent(authEvent);
        
        // Evento de compatibilidade com login
        const loginEvent = new CustomEvent('auth_login_success', { 
          detail: { 
            source: 'tokenRefresh',
            timestamp: new Date().toISOString()
          } 
        });
        console.log("üöÄ [TOKEN EVENT] Disparando evento de compatibilidade auth_login_success");
        window.dispatchEvent(loginEvent);
        
        // Evento customizado para l√≥gica de retry
        try {
          if (window.handleTokenRefreshAndRetry && typeof window.handleTokenRefreshAndRetry === 'function') {
            console.log("üîÑ [TOKEN EVENT] Chamando handler customizado");
            window.handleTokenRefreshAndRetry();
          }
        } catch (handlerError) {
          console.error("‚ùå [TOKEN EVENT] Erro ao chamar handler customizado:", handlerError);
        }
        
        console.log("üì° [TOKEN EVENT] Eventos de refresh disparados com sucesso");
        console.log("‚úÖ Refresh do token bem-sucedido");
        return true;
      } catch (requestError) {
        clearTimeout(timeoutId);
        throw requestError;
      }
    } catch (error) {
      console.error("‚ùå Refresh do token falhou", {
        error: (error as Error).message,
        attempt: currentAttempts + 1,
        maxAttempts
      });
      
      // Se for a √∫ltima tentativa, disparar falha de autentica√ß√£o
      if (currentAttempts + 1 >= maxAttempts) {
        this.handleAuthFailure();
      }
      
      return false;
    }
  }

  /**
   * Verificar se refresh token existe
   */
  private hasRefreshToken(): boolean {
    return !!localStorageManager.getRefreshToken();
  }

  /**
   * Verificar se endpoint √© relacionado a refresh
   */
  private isRefreshEndpoint(endpoint: string): boolean {
    return (
      endpoint.includes("/token/refresh/") ||
      endpoint.includes("/logout/") ||
      endpoint.includes("/register/") ||
      endpoint.includes("/login/")
    );
  }

  /**
   * Tratar falha de autentica√ß√£o
   */
  private handleAuthFailure(): void {
    console.log("Falha de autentica√ß√£o - limpando dados de auth");

    // N√£o limpar tokens em caso de login ativo
    const recentLoginAttempt = localStorage.getItem('recentLoginAttempt');
    const currentTime = Date.now();
    const isPostLogin = recentLoginAttempt && (currentTime - parseInt(recentLoginAttempt)) < 10000;
    
    if (isPostLogin) {
      console.log("Falha de autentica√ß√£o durante login - preservando tokens");
      return;
    }

    localStorageManager.clearAuthData();

    // Redirecionar para login para rotas protegidas
    const publicPages = ["/", "/home", "/market", "/login", "/signup", "/demo"];
    const currentPath = window.location.pathname;

    if (
      !publicPages.includes(currentPath) &&
      !currentPath.startsWith("/public")
    ) {
      console.log("Redirecionando para login", { from: currentPath });
      window.location.href = "/login";
    }
  }

  /**
   * M√©todos HTTP com flag de autentica√ß√£o
   */

  async get(endpoint: string, authenticated = true): Promise<any> {
    return this.request(endpoint, {
      method: "GET",
      authenticated,
    });
  }

  async post(endpoint: string, data: any, authenticated = true): Promise<any> {
    // Se o endpoint √© login, registrar isso para o sistema de refresh
    if (endpoint.includes('/login')) {
      localStorage.setItem('recentLoginAttempt', Date.now().toString());
    }
    
    return this.request(endpoint, {
      method: "POST",
      body: JSON.stringify(data),
      authenticated,
    });
  }

  async put(endpoint: string, data: any, authenticated = true): Promise<any> {
    return this.request(endpoint, {
      method: "PUT",
      body: JSON.stringify(data),
      authenticated,
    });
  }

  async patch(endpoint: string, data: any, authenticated = true): Promise<any> {
    return this.request(endpoint, {
      method: "PATCH",
      body: JSON.stringify(data),
      authenticated,
    });
  }

  async delete(endpoint: string, authenticated = true): Promise<any> {
    return this.request(endpoint, {
      method: "DELETE",
      authenticated,
    });
  }

  /**
   * Upload de arquivo com rastreamento de progresso
   */
  async uploadFile(
    endpoint: string,
    file: File,
    onProgress?: (progress: number) => void,
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      const formData = new FormData();
      formData.append("file", file);

      // Rastreamento de progresso
      if (onProgress) {
        xhr.upload.addEventListener("progress", (e) => {
          if (e.lengthComputable) {
            const progress = (e.loaded / e.total) * 100;
            onProgress(progress);
          }
        });
      }

      xhr.addEventListener("load", () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            const response = JSON.parse(xhr.responseText);
            resolve(response);
          } catch {
            resolve(xhr.responseText);
          }
        } else {
          reject(new Error(`Upload failed: ${xhr.status}`));
        }
      });

      xhr.addEventListener("error", () => {
        reject(new Error("Upload failed"));
      });

      // Definir headers
      const token = localStorageManager.getAuthToken();
      if (token) {
        xhr.setRequestHeader("Authorization", `Bearer ${token}`);
      }
      xhr.setRequestHeader("X-API-Key", API_KEY);

      const fingerprint = localStorageManager.getDeviceFingerprint();
      if (fingerprint) {
        xhr.setRequestHeader("X-Device-ID", fingerprint.hash);
      }

      xhr.open("POST", `${BACKEND_URL}${endpoint}`);
      xhr.send(formData);
    });
  }

  /**
   * Requisi√ß√µes em lote com tratamento de erro
   */
  async batchRequest(
    requests: Array<{
      endpoint: string;
      options?: ExtendedRequestInit;
    }>,
  ): Promise<Array<{ success: boolean; data?: any; error?: string }>> {
    const results = await Promise.allSettled(
      requests.map(({ endpoint, options }) => this.request(endpoint, options)),
    );

    return results.map((result) => {
      if (result.status === "fulfilled") {
        return { success: true, data: result.value };
      } else {
        return {
          success: false,
          error:
            result.reason instanceof Error
              ? result.reason.message
              : String(result.reason),
        };
      }
    });
  }
}

// Exportar inst√¢ncia singleton
export const api = ApiService.getInstance();

// Tipos para uso na aplica√ß√£o
export interface ApiResponse<T = any> {
  data: T;
  message?: string;
  status: number;
}

export interface PaginatedResponse<T = any> {
  count: number;
  next: string | null;
  previous: string | null;
  results: T[];
}

export interface ErrorResponse {
  detail?: string;
  message?: string;
  errors?: Record<string, string[]>;
  code?: string;
}
